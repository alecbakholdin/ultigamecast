// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: query.sql

package models

import (
	"context"
	"database/sql"
)

const createPlayer = `-- name: CreatePlayer :one
INSERT INTO players (team, "name", "order")
VALUES (
        ?1,
        ?2,
        (
            SELECT 1 + IFNULL(MAX("order"), -1)
            FROM players p
            WHERE p.team = ?1
        )
    )
RETURNING id, team, name, "order"
`

type CreatePlayerParams struct {
	Team int64  `db:"team" json:"team"`
	Name string `db:"name" json:"name" validate:"required,max=64"`
}

func (q *Queries) CreatePlayer(ctx context.Context, arg CreatePlayerParams) (Player, error) {
	row := q.db.QueryRowContext(ctx, createPlayer, arg.Team, arg.Name)
	var i Player
	err := row.Scan(
		&i.ID,
		&i.Team,
		&i.Name,
		&i.Order,
	)
	return i, err
}

const createTeam = `-- name: CreateTeam :one
INSERT INTO teams ("owner", "name", "slug", "organization")
VALUES (?, ?, ?, ?)
RETURNING id, owner, name, slug, organization
`

type CreateTeamParams struct {
	Owner        int64          `db:"owner" json:"owner"`
	Name         string         `db:"name" json:"name" validate:"required,max=64"`
	Slug         string         `db:"slug" json:"slug"`
	Organization sql.NullString `db:"organization" json:"organization"`
}

func (q *Queries) CreateTeam(ctx context.Context, arg CreateTeamParams) (Team, error) {
	row := q.db.QueryRowContext(ctx, createTeam,
		arg.Owner,
		arg.Name,
		arg.Slug,
		arg.Organization,
	)
	var i Team
	err := row.Scan(
		&i.ID,
		&i.Owner,
		&i.Name,
		&i.Slug,
		&i.Organization,
	)
	return i, err
}

const createUser = `-- name: CreateUser :one
INSERT INTO users (email, password_hash)
VALUES (LOWER(?), ?)
RETURNING id, email, password_hash
`

type CreateUserParams struct {
	Email        string         `db:"email" json:"email"`
	PasswordHash sql.NullString `db:"password_hash" json:"password_hash"`
}

func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) (User, error) {
	row := q.db.QueryRowContext(ctx, createUser, arg.Email, arg.PasswordHash)
	var i User
	err := row.Scan(&i.ID, &i.Email, &i.PasswordHash)
	return i, err
}

const getTeam = `-- name: GetTeam :one
SELECT id, owner, name, slug, organization
FROM teams
WHERE slug = LOWER(?1)
`

func (q *Queries) GetTeam(ctx context.Context, slug string) (Team, error) {
	row := q.db.QueryRowContext(ctx, getTeam, slug)
	var i Team
	err := row.Scan(
		&i.ID,
		&i.Owner,
		&i.Name,
		&i.Slug,
		&i.Organization,
	)
	return i, err
}

const getUser = `-- name: GetUser :one
SELECT id, email, password_hash
FROM users
WHERE email = LOWER(?1)
`

func (q *Queries) GetUser(ctx context.Context, email string) (User, error) {
	row := q.db.QueryRowContext(ctx, getUser, email)
	var i User
	err := row.Scan(&i.ID, &i.Email, &i.PasswordHash)
	return i, err
}

const listTeamPlayers = `-- name: ListTeamPlayers :many
SELECT p.id, p.team, p.name, p."order"
FROM players p
    INNER JOIN teams t ON p.team = t.id
WHERE t.slug = LOWER(?1)
ORDER BY p.order ASC
`

func (q *Queries) ListTeamPlayers(ctx context.Context, slug string) ([]Player, error) {
	rows, err := q.db.QueryContext(ctx, listTeamPlayers, slug)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Player
	for rows.Next() {
		var i Player
		if err := rows.Scan(
			&i.ID,
			&i.Team,
			&i.Name,
			&i.Order,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTournaments = `-- name: ListTournaments :many
SELECT tournaments.id, tournaments.team, tournaments.name, tournaments.slug, tournaments.start_date, tournaments.end_date, tournaments.location
FROM tournaments
    INNER JOIN teams ON tournaments.team = teams.id
WHERE teams.slug = LOWER(?1)
`

func (q *Queries) ListTournaments(ctx context.Context, slug string) ([]Tournament, error) {
	rows, err := q.db.QueryContext(ctx, listTournaments, slug)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Tournament
	for rows.Next() {
		var i Tournament
		if err := rows.Scan(
			&i.ID,
			&i.Team,
			&i.Name,
			&i.Slug,
			&i.StartDate,
			&i.EndDate,
			&i.Location,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updatePlayer = `-- name: UpdatePlayer :one
UPDATE players
SET "name" = ?
WHERE id = ?
RETURNING id, team, name, "order"
`

type UpdatePlayerParams struct {
	Name string `db:"name" json:"name" validate:"required,max=64"`
	ID   int64  `db:"id" json:"id"`
}

func (q *Queries) UpdatePlayer(ctx context.Context, arg UpdatePlayerParams) (Player, error) {
	row := q.db.QueryRowContext(ctx, updatePlayer, arg.Name, arg.ID)
	var i Player
	err := row.Scan(
		&i.ID,
		&i.Team,
		&i.Name,
		&i.Order,
	)
	return i, err
}

const updateTeam = `-- name: UpdateTeam :one
UPDATE teams
SET "name" = ?,
    organization = ?
WHERE teams.slug = ?
RETURNING id, owner, name, slug, organization
`

type UpdateTeamParams struct {
	Name         string         `db:"name" json:"name" validate:"required,max=64"`
	Organization sql.NullString `db:"organization" json:"organization"`
	Slug         string         `db:"slug" json:"slug"`
}

func (q *Queries) UpdateTeam(ctx context.Context, arg UpdateTeamParams) (Team, error) {
	row := q.db.QueryRowContext(ctx, updateTeam, arg.Name, arg.Organization, arg.Slug)
	var i Team
	err := row.Scan(
		&i.ID,
		&i.Owner,
		&i.Name,
		&i.Slug,
		&i.Organization,
	)
	return i, err
}
