package view_team_schedule

import "ultigamecast/internal/models"
import "ultigamecast/internal/ctxvar"
import "time"
import "log/slog"
import "strconv"

templ Schedule(schedule []models.TournamentSummary) {
	<div class="flex flex-col py-4 px-2">
		<div id="schedule-list" class="flex flex-col gap-2">
			for _, tg := range schedule {
				@ScheduleRow(&tg)
			}
		</div>
		if ctxvar.IsAdmin(ctx) {
			<div class="flex gap-3">
				<div class="buttons -ml-3.5">
					<a
						hx-get={ ctxvar.Url(ctx, ctxvar.Team, "schedule-create") }
						hx-target="#modal-content"
						hx-swap="innerHTML"
						class="button is-primary rounded-full htmx-loading"
						hx-on:mouseover="this.querySelector('.w-0').style.width = '9.75rem'"
						hx-on:mouseout="this.querySelector('.w-0').style.width = '0px'"
					>
						<span class="icon !-mr-2"><i class="fas fa-plus"></i></span>
						<span class="overflow-clip w-0 transition-all"><span class="ml-4">New Tournament</span></span>
					</a>
				</div>
			</div>
		}
	</div>
}

templ ScheduleRow(t *models.TournamentSummary) {
	<div class="flex gap-3">
		<div class="flex flex-col items-center gap-3">
			<div class="mt-[0.625rem]">
				<div class="w-3 h-3 rounded-full has-background-primary"></div>
			</div>
			<div class="w-0.5 h-full has-background-primary"></div>
		</div>
		<div class="flex flex-col gap-2 pb-4">
			<a href={ ctxvar.SafeUrl(ctx, ctxvar.Team, t) } class="is-size-5">{ t.Name }</a>
			<span class="flex items-center !gap-1">
				<span class="icon"><i class="fa-regular fa-calendar"></i></span>
				if t.StartDate.Time.IsZero() {
					<span>?</span>
				} else {
					<span>{ t.StartDate.Time.Format("Jan 2") }</span>
				}
				<span>-</span>
				if t.EndDate.Time.IsZero() {
					<span>?</span>
				} else {
					<span>{ t.EndDate.Time.Format("Jan 2") }</span>
				}
			</span>
			for _, td := range t.Data {
				if td.ShowInPreview.Int64 == 1 {
					<span class="flex items-center gap-1">
						<span class="icon"><i class={ "fas", td.Icon }></i></span>
						<span>{ td.TextPreview }</span>
					</span>
				}
			}
			<span class="h-0"></span> // spacing
			for i, games := range groupGamesByDate(ctx, t) {
				if len(games) > 0 && i > 0 {
					<span>Day { strconv.FormatInt(int64(i), 10) }</span>
				}
				for _, g := range games {
					<a href={ ctxvar.SafeUrl(ctx, ctxvar.Team, t, &g) }>
						{ string(g.ScheduleStatus) }
						vs { g.Opponent }
					</a>
				}
			}
		</div>
	</div>
}

type groupedGames map[int][]models.Game

func groupGamesByDate(ctx context.Context, tournamentSummary *models.TournamentSummary) groupedGames {
	m := make(groupedGames)
	tournamentStart := tournamentSummary.StartDate.Time
	for _, g := range tournamentSummary.Games {
		if tournamentStart.IsZero() || !g.StartTimezone.Valid || !g.Start.Valid {
			m[0] = append(m[0], g)
			continue
		}
		loc, err := time.LoadLocation(g.StartTimezone.String)
		if err != nil {
			m[0] = append(m[0], g)
			slog.ErrorContext(ctx, "error parsing game timezone", "game", g, "loc", loc, "err", err)
			continue
		}
		timeInLoc := g.Start.Time.In(loc)
		daysSinceStart := int(timeInLoc.Sub(tournamentStart).Hours()/24) + 1
		m[daysSinceStart] = append(m[daysSinceStart], g)
	}
	return m
}
