// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: query.sql

package models

import (
	"context"
	"database/sql"
	"strings"
)

const createEvent = `-- name: CreateEvent :one
INSERT INTO events (
        id,
        batch,
        game,
        team_score,
        opponent_score,
        previous_game_state,
        previous_event,
        "type",
        player
    )
VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
RETURNING id, batch, created, team_score, opponent_score, game, type, player, previous_game_state, previous_event
`

type CreateEventParams struct {
	ID                string         `db:"id" json:"id"`
	Batch             sql.NullString `db:"batch" json:"batch"`
	Game              int64          `db:"game" json:"game"`
	TeamScore         int64          `db:"team_score" json:"team_score"`
	OpponentScore     int64          `db:"opponent_score" json:"opponent_score"`
	PreviousGameState GameLiveStatus `db:"previous_game_state" json:"previous_game_state"`
	PreviousEvent     sql.NullString `db:"previous_event" json:"previous_event"`
	Type              EventType      `db:"type" json:"type"`
	Player            sql.NullInt64  `db:"player" json:"player"`
}

func (q *Queries) CreateEvent(ctx context.Context, arg CreateEventParams) (Event, error) {
	row := q.db.QueryRowContext(ctx, createEvent,
		arg.ID,
		arg.Batch,
		arg.Game,
		arg.TeamScore,
		arg.OpponentScore,
		arg.PreviousGameState,
		arg.PreviousEvent,
		arg.Type,
		arg.Player,
	)
	var i Event
	err := row.Scan(
		&i.ID,
		&i.Batch,
		&i.Created,
		&i.TeamScore,
		&i.OpponentScore,
		&i.Game,
		&i.Type,
		&i.Player,
		&i.PreviousGameState,
		&i.PreviousEvent,
	)
	return i, err
}

const createGame = `-- name: CreateGame :one
INSERT INTO games (
        tournament,
        opponent,
        slug,
        "start",
        "start_timezone",
        "half_cap",
        "soft_cap",
        "hard_cap"
    )
VALUES (?, ?, ?, ?, ?, ?, ?, ?)
RETURNING id, tournament, slug, opponent, start, start_timezone, wind, "temp", half_cap, soft_cap, hard_cap, schedule_status, live_status, active_players, last_event, team_score, opponent_score
`

type CreateGameParams struct {
	Tournament    int64          `db:"tournament" json:"tournament"`
	Opponent      string         `db:"opponent" json:"opponent"`
	Slug          string         `db:"slug" json:"slug"`
	Start         sql.NullTime   `db:"start" json:"start"`
	StartTimezone sql.NullString `db:"start_timezone" json:"start_timezone"`
	HalfCap       sql.NullInt64  `db:"half_cap" json:"half_cap"`
	SoftCap       sql.NullInt64  `db:"soft_cap" json:"soft_cap"`
	HardCap       sql.NullInt64  `db:"hard_cap" json:"hard_cap"`
}

func (q *Queries) CreateGame(ctx context.Context, arg CreateGameParams) (Game, error) {
	row := q.db.QueryRowContext(ctx, createGame,
		arg.Tournament,
		arg.Opponent,
		arg.Slug,
		arg.Start,
		arg.StartTimezone,
		arg.HalfCap,
		arg.SoftCap,
		arg.HardCap,
	)
	var i Game
	err := row.Scan(
		&i.ID,
		&i.Tournament,
		&i.Slug,
		&i.Opponent,
		&i.Start,
		&i.StartTimezone,
		&i.Wind,
		&i.Temp,
		&i.HalfCap,
		&i.SoftCap,
		&i.HardCap,
		&i.ScheduleStatus,
		&i.LiveStatus,
		&i.ActivePlayers,
		&i.LastEvent,
		&i.TeamScore,
		&i.OpponentScore,
	)
	return i, err
}

const createPlayer = `-- name: CreatePlayer :one
INSERT INTO players (team, slug, "name", "order")
VALUES (
        ?1,
        ?2,
        ?3,
        (
            SELECT 1 + IFNULL(MAX("order"), -1)
            FROM players p
            WHERE p.team = ?1
        )
    )
RETURNING id, team, slug, name, "order"
`

type CreatePlayerParams struct {
	Team int64  `db:"team" json:"team"`
	Slug string `db:"slug" json:"slug"`
	Name string `db:"name" json:"name"`
}

func (q *Queries) CreatePlayer(ctx context.Context, arg CreatePlayerParams) (Player, error) {
	row := q.db.QueryRowContext(ctx, createPlayer, arg.Team, arg.Slug, arg.Name)
	var i Player
	err := row.Scan(
		&i.ID,
		&i.Team,
		&i.Slug,
		&i.Name,
		&i.Order,
	)
	return i, err
}

const createTeam = `-- name: CreateTeam :one
INSERT INTO teams ("owner", "name", "slug", "organization")
VALUES (?, ?, ?, ?)
RETURNING id, owner, name, slug, organization
`

type CreateTeamParams struct {
	Owner        int64          `db:"owner" json:"owner"`
	Name         string         `db:"name" json:"name"`
	Slug         string         `db:"slug" json:"slug"`
	Organization sql.NullString `db:"organization" json:"organization"`
}

func (q *Queries) CreateTeam(ctx context.Context, arg CreateTeamParams) (Team, error) {
	row := q.db.QueryRowContext(ctx, createTeam,
		arg.Owner,
		arg.Name,
		arg.Slug,
		arg.Organization,
	)
	var i Team
	err := row.Scan(
		&i.ID,
		&i.Owner,
		&i.Name,
		&i.Slug,
		&i.Organization,
	)
	return i, err
}

const createTournament = `-- name: CreateTournament :one
INSERT INTO tournaments (team, "name", slug, "start_date", end_date)
VALUES (?, ?, ?, ?, ?)
RETURNING id, team, name, slug, start_date, end_date, location
`

type CreateTournamentParams struct {
	TeamId    int64        `db:"teamId" json:"teamId"`
	Name      string       `db:"name" json:"name"`
	Slug      string       `db:"slug" json:"slug"`
	StartDate sql.NullTime `db:"start_date" json:"start_date"`
	EndDate   sql.NullTime `db:"end_date" json:"end_date"`
}

func (q *Queries) CreateTournament(ctx context.Context, arg CreateTournamentParams) (Tournament, error) {
	row := q.db.QueryRowContext(ctx, createTournament,
		arg.TeamId,
		arg.Name,
		arg.Slug,
		arg.StartDate,
		arg.EndDate,
	)
	var i Tournament
	err := row.Scan(
		&i.ID,
		&i.Team,
		&i.Name,
		&i.Slug,
		&i.StartDate,
		&i.EndDate,
		&i.Location,
	)
	return i, err
}

const createTournamentDatum = `-- name: CreateTournamentDatum :one
INSERT INTO tournament_data (tournament, "order")
VALUES (
        ?1,
        (
            SELECT 1 + IFNULL(MAX("order"), -1)
            FROM tournament_data
            WHERE tournament = ?1
        )
    )
RETURNING id, tournament, icon, title, show_in_preview, text_preview, data_type, value_text, value_link, "order"
`

func (q *Queries) CreateTournamentDatum(ctx context.Context, tournamentid int64) (TournamentDatum, error) {
	row := q.db.QueryRowContext(ctx, createTournamentDatum, tournamentid)
	var i TournamentDatum
	err := row.Scan(
		&i.ID,
		&i.Tournament,
		&i.Icon,
		&i.Title,
		&i.ShowInPreview,
		&i.TextPreview,
		&i.DataType,
		&i.ValueText,
		&i.ValueLink,
		&i.Order,
	)
	return i, err
}

const createUser = `-- name: CreateUser :one
INSERT INTO users (email, password_hash)
VALUES (LOWER(?), ?)
RETURNING id, email, password_hash
`

type CreateUserParams struct {
	Email        string         `db:"email" json:"email"`
	PasswordHash sql.NullString `db:"password_hash" json:"password_hash"`
}

func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) (User, error) {
	row := q.db.QueryRowContext(ctx, createUser, arg.Email, arg.PasswordHash)
	var i User
	err := row.Scan(&i.ID, &i.Email, &i.PasswordHash)
	return i, err
}

const getGameById = `-- name: GetGameById :one
SELECT id, tournament, slug, opponent, start, start_timezone, wind, "temp", half_cap, soft_cap, hard_cap, schedule_status, live_status, active_players, last_event, team_score, opponent_score
FROM games
WHERE id = ?
`

func (q *Queries) GetGameById(ctx context.Context, id int64) (Game, error) {
	row := q.db.QueryRowContext(ctx, getGameById, id)
	var i Game
	err := row.Scan(
		&i.ID,
		&i.Tournament,
		&i.Slug,
		&i.Opponent,
		&i.Start,
		&i.StartTimezone,
		&i.Wind,
		&i.Temp,
		&i.HalfCap,
		&i.SoftCap,
		&i.HardCap,
		&i.ScheduleStatus,
		&i.LiveStatus,
		&i.ActivePlayers,
		&i.LastEvent,
		&i.TeamScore,
		&i.OpponentScore,
	)
	return i, err
}

const getGameBySlug = `-- name: GetGameBySlug :one
SELECT id, tournament, slug, opponent, start, start_timezone, wind, "temp", half_cap, soft_cap, hard_cap, schedule_status, live_status, active_players, last_event, team_score, opponent_score
FROM games
WHERE tournament = ? AND slug = ?
`

type GetGameBySlugParams struct {
	TournamentID int64  `db:"tournamentID" json:"tournamentID"`
	Slug         string `db:"slug" json:"slug"`
}

func (q *Queries) GetGameBySlug(ctx context.Context, arg GetGameBySlugParams) (Game, error) {
	row := q.db.QueryRowContext(ctx, getGameBySlug, arg.TournamentID, arg.Slug)
	var i Game
	err := row.Scan(
		&i.ID,
		&i.Tournament,
		&i.Slug,
		&i.Opponent,
		&i.Start,
		&i.StartTimezone,
		&i.Wind,
		&i.Temp,
		&i.HalfCap,
		&i.SoftCap,
		&i.HardCap,
		&i.ScheduleStatus,
		&i.LiveStatus,
		&i.ActivePlayers,
		&i.LastEvent,
		&i.TeamScore,
		&i.OpponentScore,
	)
	return i, err
}

const getPlayer = `-- name: GetPlayer :one
SELECT id, team, slug, name, "order"
FROM players
WHERE team = ?1
    AND slug = ?2
`

type GetPlayerParams struct {
	TeamId int64  `db:"teamId" json:"teamId"`
	Slug   string `db:"slug" json:"slug"`
}

func (q *Queries) GetPlayer(ctx context.Context, arg GetPlayerParams) (Player, error) {
	row := q.db.QueryRowContext(ctx, getPlayer, arg.TeamId, arg.Slug)
	var i Player
	err := row.Scan(
		&i.ID,
		&i.Team,
		&i.Slug,
		&i.Name,
		&i.Order,
	)
	return i, err
}

const getTeam = `-- name: GetTeam :one
SELECT id, owner, name, slug, organization
FROM teams
WHERE slug = LOWER(?1)
`

func (q *Queries) GetTeam(ctx context.Context, slug string) (Team, error) {
	row := q.db.QueryRowContext(ctx, getTeam, slug)
	var i Team
	err := row.Scan(
		&i.ID,
		&i.Owner,
		&i.Name,
		&i.Slug,
		&i.Organization,
	)
	return i, err
}

const getTournament = `-- name: GetTournament :one
SELECT id, team, name, slug, start_date, end_date, location
FROM tournaments
WHERE team = ?1
    AND slug = ?2
`

type GetTournamentParams struct {
	TeamId int64  `db:"teamId" json:"teamId"`
	Slug   string `db:"slug" json:"slug"`
}

func (q *Queries) GetTournament(ctx context.Context, arg GetTournamentParams) (Tournament, error) {
	row := q.db.QueryRowContext(ctx, getTournament, arg.TeamId, arg.Slug)
	var i Tournament
	err := row.Scan(
		&i.ID,
		&i.Team,
		&i.Name,
		&i.Slug,
		&i.StartDate,
		&i.EndDate,
		&i.Location,
	)
	return i, err
}

const getTournamentDatum = `-- name: GetTournamentDatum :one
SELECT id, tournament, icon, title, show_in_preview, text_preview, data_type, value_text, value_link, "order"
FROM tournament_data
WHERE id = ?1
    AND tournament = ?2
`

type GetTournamentDatumParams struct {
	DataId       int64 `db:"dataId" json:"dataId"`
	TournamentId int64 `db:"tournamentId" json:"tournamentId"`
}

func (q *Queries) GetTournamentDatum(ctx context.Context, arg GetTournamentDatumParams) (TournamentDatum, error) {
	row := q.db.QueryRowContext(ctx, getTournamentDatum, arg.DataId, arg.TournamentId)
	var i TournamentDatum
	err := row.Scan(
		&i.ID,
		&i.Tournament,
		&i.Icon,
		&i.Title,
		&i.ShowInPreview,
		&i.TextPreview,
		&i.DataType,
		&i.ValueText,
		&i.ValueLink,
		&i.Order,
	)
	return i, err
}

const getUser = `-- name: GetUser :one
SELECT id, email, password_hash
FROM users
WHERE email = LOWER(?1)
`

func (q *Queries) GetUser(ctx context.Context, email string) (User, error) {
	row := q.db.QueryRowContext(ctx, getUser, email)
	var i User
	err := row.Scan(&i.ID, &i.Email, &i.PasswordHash)
	return i, err
}

const listFollowedTeams = `-- name: ListFollowedTeams :many
SELECT t.id, t.owner, t.name, t.slug, t.organization
FROM team_follow tf
    INNER JOIN teams t ON t.id = tf.team
WHERE tf.user = ?1
ORDER BY t.name ASC
`

func (q *Queries) ListFollowedTeams(ctx context.Context, userid int64) ([]Team, error) {
	rows, err := q.db.QueryContext(ctx, listFollowedTeams, userid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Team
	for rows.Next() {
		var i Team
		if err := rows.Scan(
			&i.ID,
			&i.Owner,
			&i.Name,
			&i.Slug,
			&i.Organization,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listOwnedTeams = `-- name: ListOwnedTeams :many
SELECT id, owner, name, slug, organization
FROM teams
WHERE teams.owner = ?1
ORDER BY id DESC
`

func (q *Queries) ListOwnedTeams(ctx context.Context, userid int64) ([]Team, error) {
	rows, err := q.db.QueryContext(ctx, listOwnedTeams, userid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Team
	for rows.Next() {
		var i Team
		if err := rows.Scan(
			&i.ID,
			&i.Owner,
			&i.Name,
			&i.Slug,
			&i.Organization,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTeamGames = `-- name: ListTeamGames :many
SELECT g.id, g.tournament, g.slug, g.opponent, g.start, g.start_timezone, g.wind, g."temp", g.half_cap, g.soft_cap, g.hard_cap, g.schedule_status, g.live_status, g.active_players, g.last_event, g.team_score, g.opponent_score
FROM games g
    INNER JOIN tournaments t ON t.id = g.tournament
WHERE t.team = ?1
ORDER BY g.start ASC
`

func (q *Queries) ListTeamGames(ctx context.Context, teamid int64) ([]Game, error) {
	rows, err := q.db.QueryContext(ctx, listTeamGames, teamid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Game
	for rows.Next() {
		var i Game
		if err := rows.Scan(
			&i.ID,
			&i.Tournament,
			&i.Slug,
			&i.Opponent,
			&i.Start,
			&i.StartTimezone,
			&i.Wind,
			&i.Temp,
			&i.HalfCap,
			&i.SoftCap,
			&i.HardCap,
			&i.ScheduleStatus,
			&i.LiveStatus,
			&i.ActivePlayers,
			&i.LastEvent,
			&i.TeamScore,
			&i.OpponentScore,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTeamPlayers = `-- name: ListTeamPlayers :many
SELECT id, team, slug, name, "order"
FROM players
WHERE team = ?1
ORDER BY "order" ASC
`

func (q *Queries) ListTeamPlayers(ctx context.Context, teamid int64) ([]Player, error) {
	rows, err := q.db.QueryContext(ctx, listTeamPlayers, teamid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Player
	for rows.Next() {
		var i Player
		if err := rows.Scan(
			&i.ID,
			&i.Team,
			&i.Slug,
			&i.Name,
			&i.Order,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTeamPlayersByID = `-- name: ListTeamPlayersByID :many
SELECT id, team, slug, name, "order"
FROM players
WHERE team = ?1
    AND id IN (?2)
`

type ListTeamPlayersByIDParams struct {
	TeamId    int64 `db:"teamId" json:"teamId"`
	PlayerIDs int64 `db:"playerIDs" json:"playerIDs"`
}

func (q *Queries) ListTeamPlayersByID(ctx context.Context, arg ListTeamPlayersByIDParams) ([]Player, error) {
	rows, err := q.db.QueryContext(ctx, listTeamPlayersByID, arg.TeamId, arg.PlayerIDs)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Player
	for rows.Next() {
		var i Player
		if err := rows.Scan(
			&i.ID,
			&i.Team,
			&i.Slug,
			&i.Name,
			&i.Order,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTeamPlayersBySlug = `-- name: ListTeamPlayersBySlug :many
SELECT id, team, slug, name, "order"
FROM players
WHERE team = ?1
    AND slug IN (/*SLICE:playerSlugs*/?)
`

type ListTeamPlayersBySlugParams struct {
	TeamId      int64    `db:"teamId" json:"teamId"`
	PlayerSlugs []string `db:"playerSlugs" json:"playerSlugs"`
}

func (q *Queries) ListTeamPlayersBySlug(ctx context.Context, arg ListTeamPlayersBySlugParams) ([]Player, error) {
	query := listTeamPlayersBySlug
	var queryParams []interface{}
	queryParams = append(queryParams, arg.TeamId)
	if len(arg.PlayerSlugs) > 0 {
		for _, v := range arg.PlayerSlugs {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:playerSlugs*/?", strings.Repeat(",?", len(arg.PlayerSlugs))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:playerSlugs*/?", "NULL", 1)
	}
	rows, err := q.db.QueryContext(ctx, query, queryParams...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Player
	for rows.Next() {
		var i Player
		if err := rows.Scan(
			&i.ID,
			&i.Team,
			&i.Slug,
			&i.Name,
			&i.Order,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTeamTournamentData = `-- name: ListTeamTournamentData :many
SELECT td.id, td.tournament, td.icon, td.title, td.show_in_preview, td.text_preview, td.data_type, td.value_text, td.value_link, td."order"
FROM tournament_data td
    INNER JOIN tournaments t
WHERE t.team = ?1
ORDER BY td."order" ASC
`

func (q *Queries) ListTeamTournamentData(ctx context.Context, teamid int64) ([]TournamentDatum, error) {
	rows, err := q.db.QueryContext(ctx, listTeamTournamentData, teamid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []TournamentDatum
	for rows.Next() {
		var i TournamentDatum
		if err := rows.Scan(
			&i.ID,
			&i.Tournament,
			&i.Icon,
			&i.Title,
			&i.ShowInPreview,
			&i.TextPreview,
			&i.DataType,
			&i.ValueText,
			&i.ValueLink,
			&i.Order,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTournamentData = `-- name: ListTournamentData :many
SELECT id, tournament, icon, title, show_in_preview, text_preview, data_type, value_text, value_link, "order"
FROM tournament_data
WHERE tournament = ?1
ORDER BY "order" ASC
`

func (q *Queries) ListTournamentData(ctx context.Context, tournamentid int64) ([]TournamentDatum, error) {
	rows, err := q.db.QueryContext(ctx, listTournamentData, tournamentid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []TournamentDatum
	for rows.Next() {
		var i TournamentDatum
		if err := rows.Scan(
			&i.ID,
			&i.Tournament,
			&i.Icon,
			&i.Title,
			&i.ShowInPreview,
			&i.TextPreview,
			&i.DataType,
			&i.ValueText,
			&i.ValueLink,
			&i.Order,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTournamentGames = `-- name: ListTournamentGames :many
SELECT id, tournament, slug, opponent, start, start_timezone, wind, "temp", half_cap, soft_cap, hard_cap, schedule_status, live_status, active_players, last_event, team_score, opponent_score
FROM games
WHERE tournament = ?1
ORDER BY "start"
`

func (q *Queries) ListTournamentGames(ctx context.Context, tournamentid int64) ([]Game, error) {
	rows, err := q.db.QueryContext(ctx, listTournamentGames, tournamentid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Game
	for rows.Next() {
		var i Game
		if err := rows.Scan(
			&i.ID,
			&i.Tournament,
			&i.Slug,
			&i.Opponent,
			&i.Start,
			&i.StartTimezone,
			&i.Wind,
			&i.Temp,
			&i.HalfCap,
			&i.SoftCap,
			&i.HardCap,
			&i.ScheduleStatus,
			&i.LiveStatus,
			&i.ActivePlayers,
			&i.LastEvent,
			&i.TeamScore,
			&i.OpponentScore,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTournaments = `-- name: ListTournaments :many
SELECT id, team, name, slug, start_date, end_date, location
FROM tournaments
WHERE team = ?1
ORDER BY "start_date" ASC,
    id ASC
`

func (q *Queries) ListTournaments(ctx context.Context, teamid int64) ([]Tournament, error) {
	rows, err := q.db.QueryContext(ctx, listTournaments, teamid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Tournament
	for rows.Next() {
		var i Tournament
		if err := rows.Scan(
			&i.ID,
			&i.Team,
			&i.Name,
			&i.Slug,
			&i.StartDate,
			&i.EndDate,
			&i.Location,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateGameScheduleStatus = `-- name: UpdateGameScheduleStatus :one
UPDATE games
SET schedule_status = ?
WHERE id = ?
RETURNING id, tournament, slug, opponent, start, start_timezone, wind, "temp", half_cap, soft_cap, hard_cap, schedule_status, live_status, active_players, last_event, team_score, opponent_score
`

type UpdateGameScheduleStatusParams struct {
	ScheduleStatus GameScheduleStatus `db:"schedule_status" json:"schedule_status"`
	ID             int64              `db:"id" json:"id"`
}

func (q *Queries) UpdateGameScheduleStatus(ctx context.Context, arg UpdateGameScheduleStatusParams) (Game, error) {
	row := q.db.QueryRowContext(ctx, updateGameScheduleStatus, arg.ScheduleStatus, arg.ID)
	var i Game
	err := row.Scan(
		&i.ID,
		&i.Tournament,
		&i.Slug,
		&i.Opponent,
		&i.Start,
		&i.StartTimezone,
		&i.Wind,
		&i.Temp,
		&i.HalfCap,
		&i.SoftCap,
		&i.HardCap,
		&i.ScheduleStatus,
		&i.LiveStatus,
		&i.ActivePlayers,
		&i.LastEvent,
		&i.TeamScore,
		&i.OpponentScore,
	)
	return i, err
}

const updateLiveGame = `-- name: UpdateLiveGame :one
UPDATE games
SET team_score = ?,
    opponent_score = ?,
    live_status = ?,
    last_event = ?,
    active_players = ?
WHERE id = ?
RETURNING id, tournament, slug, opponent, start, start_timezone, wind, "temp", half_cap, soft_cap, hard_cap, schedule_status, live_status, active_players, last_event, team_score, opponent_score
`

type UpdateLiveGameParams struct {
	TeamScore     int64          `db:"team_score" json:"team_score"`
	OpponentScore int64          `db:"opponent_score" json:"opponent_score"`
	LiveStatus    GameLiveStatus `db:"live_status" json:"live_status"`
	LastEvent     sql.NullString `db:"last_event" json:"last_event"`
	ActivePlayers sql.NullString `db:"active_players" json:"active_players"`
	ID            int64          `db:"id" json:"id"`
}

func (q *Queries) UpdateLiveGame(ctx context.Context, arg UpdateLiveGameParams) (Game, error) {
	row := q.db.QueryRowContext(ctx, updateLiveGame,
		arg.TeamScore,
		arg.OpponentScore,
		arg.LiveStatus,
		arg.LastEvent,
		arg.ActivePlayers,
		arg.ID,
	)
	var i Game
	err := row.Scan(
		&i.ID,
		&i.Tournament,
		&i.Slug,
		&i.Opponent,
		&i.Start,
		&i.StartTimezone,
		&i.Wind,
		&i.Temp,
		&i.HalfCap,
		&i.SoftCap,
		&i.HardCap,
		&i.ScheduleStatus,
		&i.LiveStatus,
		&i.ActivePlayers,
		&i.LastEvent,
		&i.TeamScore,
		&i.OpponentScore,
	)
	return i, err
}

const updatePlayer = `-- name: UpdatePlayer :one
UPDATE players
SET "name" = ?,
    slug = ?
WHERE id = ?
RETURNING id, team, slug, name, "order"
`

type UpdatePlayerParams struct {
	Name string `db:"name" json:"name"`
	Slug string `db:"slug" json:"slug"`
	ID   int64  `db:"id" json:"id"`
}

func (q *Queries) UpdatePlayer(ctx context.Context, arg UpdatePlayerParams) (Player, error) {
	row := q.db.QueryRowContext(ctx, updatePlayer, arg.Name, arg.Slug, arg.ID)
	var i Player
	err := row.Scan(
		&i.ID,
		&i.Team,
		&i.Slug,
		&i.Name,
		&i.Order,
	)
	return i, err
}

const updatePlayerOrder = `-- name: UpdatePlayerOrder :exec
UPDATE players
SET "order" = ?
WHERE id = ?
    AND team = ?
`

type UpdatePlayerOrderParams struct {
	Order int64 `db:"order" json:"order"`
	ID    int64 `db:"id" json:"id"`
	Team  int64 `db:"team" json:"team"`
}

func (q *Queries) UpdatePlayerOrder(ctx context.Context, arg UpdatePlayerOrderParams) error {
	_, err := q.db.ExecContext(ctx, updatePlayerOrder, arg.Order, arg.ID, arg.Team)
	return err
}

const updateTeamName = `-- name: UpdateTeamName :one
UPDATE teams
SET "name" = ?,
    "slug" = ?
WHERE teams.slug = ?
RETURNING id, owner, name, slug, organization
`

type UpdateTeamNameParams struct {
	Name    string `db:"name" json:"name"`
	NewSlug string `db:"newSlug" json:"newSlug"`
	OldSlug string `db:"oldSlug" json:"oldSlug"`
}

func (q *Queries) UpdateTeamName(ctx context.Context, arg UpdateTeamNameParams) (Team, error) {
	row := q.db.QueryRowContext(ctx, updateTeamName, arg.Name, arg.NewSlug, arg.OldSlug)
	var i Team
	err := row.Scan(
		&i.ID,
		&i.Owner,
		&i.Name,
		&i.Slug,
		&i.Organization,
	)
	return i, err
}

const updateTeamOrganization = `-- name: UpdateTeamOrganization :one
UPDATE teams
SET organization = ?
WHERE teams.slug = ?
RETURNING id, owner, name, slug, organization
`

type UpdateTeamOrganizationParams struct {
	Organization sql.NullString `db:"organization" json:"organization"`
	Slug         string         `db:"slug" json:"slug"`
}

func (q *Queries) UpdateTeamOrganization(ctx context.Context, arg UpdateTeamOrganizationParams) (Team, error) {
	row := q.db.QueryRowContext(ctx, updateTeamOrganization, arg.Organization, arg.Slug)
	var i Team
	err := row.Scan(
		&i.ID,
		&i.Owner,
		&i.Name,
		&i.Slug,
		&i.Organization,
	)
	return i, err
}

const updateTeamOwner = `-- name: UpdateTeamOwner :one
UPDATE teams
SET "owner" = ?
WHERE teams.slug = ?
RETURNING id, owner, name, slug, organization
`

type UpdateTeamOwnerParams struct {
	Owner int64  `db:"owner" json:"owner"`
	Slug  string `db:"slug" json:"slug"`
}

func (q *Queries) UpdateTeamOwner(ctx context.Context, arg UpdateTeamOwnerParams) (Team, error) {
	row := q.db.QueryRowContext(ctx, updateTeamOwner, arg.Owner, arg.Slug)
	var i Team
	err := row.Scan(
		&i.ID,
		&i.Owner,
		&i.Name,
		&i.Slug,
		&i.Organization,
	)
	return i, err
}

const updateTournamentDates = `-- name: UpdateTournamentDates :one
UPDATE tournaments
SET "start_date" = ?,
    "end_date" = ?
WHERE id = ?
RETURNING id, team, name, slug, start_date, end_date, location
`

type UpdateTournamentDatesParams struct {
	StartDate    sql.NullTime `db:"start_date" json:"start_date"`
	EndDate      sql.NullTime `db:"end_date" json:"end_date"`
	TournamentId int64        `db:"tournamentId" json:"tournamentId"`
}

func (q *Queries) UpdateTournamentDates(ctx context.Context, arg UpdateTournamentDatesParams) (Tournament, error) {
	row := q.db.QueryRowContext(ctx, updateTournamentDates, arg.StartDate, arg.EndDate, arg.TournamentId)
	var i Tournament
	err := row.Scan(
		&i.ID,
		&i.Team,
		&i.Name,
		&i.Slug,
		&i.StartDate,
		&i.EndDate,
		&i.Location,
	)
	return i, err
}

const updateTournamentDatumOrder = `-- name: UpdateTournamentDatumOrder :exec
UPDATE tournament_data
SET "order" = ?
WHERE id = ?
    AND tournament = ?
`

type UpdateTournamentDatumOrderParams struct {
	Order        int64 `db:"order" json:"order"`
	DataId       int64 `db:"dataId" json:"dataId"`
	TournamentId int64 `db:"tournamentId" json:"tournamentId"`
}

func (q *Queries) UpdateTournamentDatumOrder(ctx context.Context, arg UpdateTournamentDatumOrderParams) error {
	_, err := q.db.ExecContext(ctx, updateTournamentDatumOrder, arg.Order, arg.DataId, arg.TournamentId)
	return err
}

const updateTournamentLocation = `-- name: UpdateTournamentLocation :one
UPDATE tournaments
SET "location" = ?
WHERE id = ?
RETURNING id, team, name, slug, start_date, end_date, location
`

type UpdateTournamentLocationParams struct {
	Location     sql.NullString `db:"location" json:"location"`
	TournamentId int64          `db:"tournamentId" json:"tournamentId"`
}

func (q *Queries) UpdateTournamentLocation(ctx context.Context, arg UpdateTournamentLocationParams) (Tournament, error) {
	row := q.db.QueryRowContext(ctx, updateTournamentLocation, arg.Location, arg.TournamentId)
	var i Tournament
	err := row.Scan(
		&i.ID,
		&i.Team,
		&i.Name,
		&i.Slug,
		&i.StartDate,
		&i.EndDate,
		&i.Location,
	)
	return i, err
}
